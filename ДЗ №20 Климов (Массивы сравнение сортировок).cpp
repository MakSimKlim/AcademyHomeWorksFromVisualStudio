// Задание #4
// 
// ДЗ №20 Климов (Массивы сорт пузырь 2)
//
//Написать программу, которая сравнивает число переста-
//новок элементов при использовании сортировки «пузырь -
//ком»(усовершенствованная версия задани я 2) и методом
//выбора.Выполнить ее тестирование на разных 10 массивах,
//содержащих 1000 случайных элементов, вычислить среднее
//число перестановок для каждого метода после тестирования.

#include <iostream>
#include <time.h>

using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	srand(time(NULL));


	cout << "\n ********************************************************************" << endl;
	cout << " *  Программа сортировки чисел в массиве различными способами v1.0  *" << endl;
	cout << " ********************************************************************" << endl;
	
	int N = 0;//число строк
	int M = 0;//число столбцов
	int arr[10][1000];
	int sumSteps1 = 1, sumSteps2 = 1;

	cout << "Введите число строк до 10:" << "\n";
	cin >> N;
	cout << "Введите число столбцов до 1000:" << "\n";
	cin >> M;

	cout << "\nисходные несортированные массивы:" << "\n\n";
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			arr[i][j] = 0 + rand() % (9 - 0);
			cout << arr[i][j]<<" ";
		}
		cout << "\n";
	}
	cout << "\n1). Массивы, сортированные по возрастанию методом пузырька:" << "\n\n";
		
	for (int j = 0; j < N; j++)//цикл нужный только для многомерных массивов, для перехода на нижние строки и повторение цикла сортировки строки
	{
		for (int b = 0; b < M-1; b++)//цикл прохода (шаги), количества повторений сортировки строк для полной сортировки
		{
			bool stepsOpt = 0;//оптимизация работы программы, останавливает сортировку в проходах по строкам, когда сортировать уже не имеет смысла, всё уже отсортировано
			// и не нужно до конца в холостую досчитывать "М-1" раз
			
			for (int k = 0; k < M - 1 - b; k++)//цикл сортировки (такт) элементов строки массива (их всегда на один элемент меньше размера массива)
				//оптимизация: уменьшение количества проходов (тактов) путем подстановки в условие "-b", т.к. не имеет смысла сравнивать уже отсортированное
				//т.е. цикл будет выполняться на один такт меньше
			{
				if (arr[j][k] > arr[j][k + 1])// блок обмена элементов массива
				{
					int tmp1 = arr[j][k];//tmp1 промежуточная переменная необходимая для перезаписи в блоке обмена местами элементов
					arr[j][k] = arr[j][k + 1];
					arr[j][k + 1] = tmp1;

					stepsOpt = 1;//в том случае если потребовалась смена значений
					
				}
				
			}
			//определяет произошёл ли хоть один обмен между ячейками массива в течении работы внутреннего цикла
			//и если она произошла, то есть ещё что-то, что нужно упорядочивать, если нет (0) значит массив отсортирован
			if (stepsOpt == 0)
			{
				break;
			}

			sumSteps1 += 1;//подсчет количества проходов (шагов) при сортировке
		}
		
	}

	//вывод после сортировки
	for (int x = 0; x < N; x++)
	{
		for (int y = 0; y < M; y++)
		{
			cout << arr[x][y] << " ";
		}

		cout << "\n";

	}
	cout << "отсортировано за " << sumSteps1 << " шагов" << "\n\n";

	cout << "\n2). Массивы, сортированные методом выбора:" << "\n\n";

	for (int p = 0; p < N; p++)//цикл нужный только для многомерных массивов, для перехода на нижние строки и повторение цикла сортировки строки
	{
		
		for (int z = 0; z < M-1; z++)//цикл сортировки элементов строки массива
		{
			bool stepsOpt = 0;//оптимизация работы программы, останавливает сортировку в проходах по строкам, когда сортировать уже не имеет смысла, всё уже отсортировано
			// и не нужно до конца в холостую досчитывать "М-1" раз
			
			//поиск ИНДЕКСА минимального эл-та
			int min = z;//изначально за минимальный элемент берется первый элемент массива
			for (int j = z + 1; j < M; j++)// z+1 это оптимизация, т.к. нет смыста сравнимвать первый элемент сам с собой
				//можно и без оптимизации тогда будет просто z.
			{
				if (arr[p][j]<arr[p][min])//если следующее число меньше минимального
				{
					min = j;//то минимальным становится элемент с ключом j
				}

			}

			if (z != min)// блок обмена элементов массива c минимальным значением
				//если z не равно минимальному, то меняем его местами с прошлым минимальным
			{
				int tmp2 = arr[p][z];//tmp2 промежуточная переменная необходимая для перезаписи в блоке обмена местами элементов
				arr[p][z] = arr[p][min];//обмен местами элементов массива (минимальный ставится на первое место)
				arr[p][min] = tmp2;

				stepsOpt = 1;//в том случае если потребовалась смена значений
				
				
			}

			//определяет произошёл ли хоть один обмен между ячейками массива в течении работы внутреннего цикла
			//и если она произошла, то есть ещё что-то, что нужно упорядочивать, если нет (0) значит массив отсортирован
			if (stepsOpt == 0)
			{
				break;
			}
			sumSteps2 += 1;//подсчет количества проходов (шагов) при сортировке
		}
		
	}
	//вывод после сортировки
	for (int h = 0; h < N; h++)
	{
		for (int q = 0; q < M; q++)
		{
			cout << arr[h][q] << " ";
		}
		cout << "\n";
	}
	cout << "отсортировано за " << sumSteps2 << " шагов" << "\n\n";
	
	//Вывод по способу сортировки

	if (sumSteps1 > sumSteps2)
		 cout << "Оптимален 2 вариант сортировки!\n\n";
	else cout << "Оптимален 1 вариант сортировки!\n\n";

	system("pause");

	return 0;
}
