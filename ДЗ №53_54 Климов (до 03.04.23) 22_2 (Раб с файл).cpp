// ДЗ №53 Климов (до 03.04.23) 22_2 (Раб с файл)
//
//http://cppstudio.com/post/446/
// 
// Задание 1. Добавьте к программе «Простейший файловый 
// менеджер» такие возможности :
// 1.  Создание нового файла в текущем каталоге.
// 2.  Удаление файла из текущего каталога.
// 3.  Переименование файла в текущем каталоге.
// 4.  Перемещение файла из текущего каталога в указанный
// пользователем каталог.
// 5.  Вывод содержимого указанного пользователем файла
// из текущего каталога на экран.


#include <iostream>
#include <fstream> //Для работы с файлами необходимо подключить заголовочный файл <fstream>
//В <fstream> определены несколько классов и подключены заголовочные файлы 
// <ifstream> — файловый ввод и  <ofstream>  — файловый вывод.
#include <iomanip> // манипуляторы ввода/вывода
#include <stdio.h> //для удаления файлов
#include <Windows.h> //для перемещения файлов
#include <string>// для getLine


using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");     // корректное отображение Кириллицы

	//==================================================================================
	// I. Этапы создания нового файла и записи в него информации:

	// 1). создаём объект для записи в файл

	// **********  Вариант 1:  *********************************************************
	//ofstream fout;                // fout - объект класса ofstream (это произвольное название объекта)
	//fout.open("cppstudio.txt");   // связываем объект с файлом 'cppstudio.txt'
	//                               Через операцию точка получаем доступ к методу класса open(), 
	//                               в круглых скобочках которого указываем имя файла

	// **********  Вариант 2:  *********************************************************
	//ofstream fout("cppstudio.txt"); // можно объединить эти строки
	//создаём объект класса ofstream и связываем его с файлом cppstudio.txt

	 /***********  Вариант 3:  *********************************************************
	 Режимы открытия файлов можно устанавливать непосредственно при создании объекта или при вызове функции open().
	 Режимы открытия файлов устанавливают характер использования файлов.
	 Для установки режима в классе ios_base предусмотрены константы, которые определяют режим открытия файлов
	 Вот некоторые из них:
		ios_base::in	открыть файл для чтения
		ios_base::out	открыть файл для записи
		ios_base::ate	при открытии переместить указатель в конец файла
		ios_base::app	открыть файл для записи в конец файла
		ios_base::trunc	удалить содержимое файла, если он существует
		ios_base::binary	открытие файла в двоичном режиме*/
		//Режимы открытия файлов можно комбинировать с помощью поразрядной логической операции или | , 
		//например: ios_base::out | ios_base::trunc — открытие файла для записи, предварительно очистив его.
		//Объекты класса ofstream, при связке с файлами по умолчанию содержат режимы открытия файлов  ios_base::out | ios_base::trunc.
		//То есть файл будет создан, если не существует.Если же файл существует, то его содержимое будет удалено, а сам файл будет готов к записи.
		//Объекты класса ifstream связываясь с файлом, имеют по умолчанию режим открытия файла   ios_base::in  — файл открыт только для чтения.
	ofstream fout;                             // fout - объект класса ofstream (это произвольное название объекта)
	fout.open("cppstudio.txt", ios_base::app); // открываем файл для добавления информации к концу файла

	// 2). записываем в файл нужную строчку
	fout << " Пример записи строки в файл"; // запись строки в файл
	//Используя операцию передачи в поток << совместно с объектом fout 
	//строка 'Работа с файлами в С++' записывается в файл. 

// 3). закрываем файл, то есть отделяем объект от файла.
	fout.close();                     // закрываем файл

	//==================================================================================
	// II. Этапы чтения информации из файла:

	char buff[50];                                // буфер промежуточного хранения считываемого из файла текста
	//ifstream fin("cppstudio.doc");              // (ВВЕЛИ НЕ КОРРЕКТНОЕ ИМЯ ФАЙЛА)
	ifstream fin("cppstudio.txt");                // правильное имя файла 

	// функция — is_open(), которая возвращает целые значения: 1 — если файл был успешно открыт, 0 — если файл открыт не был.
	// проверка на безошибочность открытия файла
	// рекомендуется использовать эту функцию, is_open(), даже, если уверены, что файл существует.

	if (!fin.is_open())                         // если файл не открыт
		cout << "Файл не может быть открыт!\n"; // сообщить об этом
	else
	{
		fin >> buff;                            // считали первое слово из файла
		cout << buff << endl;                   // напечатали это слово

		fin.getline(buff, 50);                  // считали строку из файла
		fin.close();                            // закрываем файл
		cout << buff << endl; // напечатали эту строку
	}
	cout << "\n";
	//==================================================================================

	// III. Пример вывода потока информации в файл используя операцию sizeof():

	//Разработаем программу, которая, используя операцию sizeof(), будет вычислять характеристики основных типов данных в С++ и записывать их в файл. Характеристики:
	// 1). число байт, отводимое под тип данных
	// 2). максимальное значение, которое может хранить определённый тип данных.

	// связываем объект с файлом, при этом файл открываем в режиме записи, предварительно удаляя все данные из него
	ofstream fout2("data_types.txt", ios_base::out | ios_base::trunc);

	if (!fout2.is_open()) // если файл небыл открыт
	{
		cout << "Файл не может быть открыт или создан\n"; // напечатать соответствующее сообщение
		return 1; // выполнить выход из программы
	}

	fout2 << "     data type      " << "byte" << "      " << "    max value  " << endl // заголовки столбцов
		<< "bool               =  " << sizeof(bool) << "         " << fixed << setprecision(2) //fixed << setprecision(2) - округление чисел до 2 знака после точки
		/*вычисляем максимальное значение для типа данных bool*/ << (pow(2, sizeof(bool) * 8.0) - 1) << endl
		<< "char               =  " << sizeof(char) << "         " << fixed << setprecision(2)
		/*вычисляем максимальное значение для типа данных char*/ << (pow(2, sizeof(char) * 8.0) - 1) << endl
		<< "short int          =  " << sizeof(short int) << "         " << fixed << setprecision(2)
		/*вычисляем максимальное значение для типа данных short int*/ << (pow(2, sizeof(short int) * 8.0 - 1) - 1) << endl
		<< "unsigned short int =  " << sizeof(unsigned short int) << "         " << fixed << setprecision(2)
		/*вычисляем максимальное значение для типа данных unsigned short int*/ << (pow(2, sizeof(unsigned short int) * 8.0) - 1) << endl
		<< "int                =  " << sizeof(int) << "         " << fixed << setprecision(2)
		/*вычисляем максимальное значение для типа данных int*/ << (pow(2, sizeof(int) * 8.0 - 1) - 1) << endl
		<< "unsigned int       =  " << sizeof(unsigned int) << "         " << fixed << setprecision(2)
		/*вычисляем максимальное значение для типа данных unsigned int*/ << (pow(2, sizeof(unsigned int) * 8.0) - 1) << endl
		<< "long int           =  " << sizeof(long int) << "         " << fixed << setprecision(2)
		/*вычисляем максимальное значение для типа данных long int*/ << (pow(2, sizeof(long int) * 8.0 - 1) - 1) << endl
		<< "unsigned long int  =  " << sizeof(unsigned long int) << "         " << fixed << setprecision(2)
		/*вычисляем максимальное значение для типа данных undigned long int*/ << (pow(2, sizeof(unsigned long int) * 8.0) - 1) << endl
		<< "float              =  " << sizeof(float) << "         " << fixed << setprecision(2)
		/*вычисляем максимальное значение для типа данных float*/ << (pow(2, sizeof(float) * 8.0 - 1) - 1) << endl
		//<< "long float         =  " << sizeof(long float) << "         " << fixed << setprecision(2)
		///*вычисляем максимальное значение для типа данных long float*/ << (pow(2, sizeof(long float) * 8.0 - 1) - 1) << endl
		<< "double             =  " << sizeof(double) << "         " << fixed << setprecision(2)
		/*вычисляем максимальное значение для типа данных double*/ << (pow(2, sizeof(double) * 8.0 - 1) - 1) << endl;
	fout2.close(); // программа больше не использует файл, поэтому его нужно закрыть
	cout << "Данные успешно записаны в файл data_types.txt\n";
	cout << "\n";
	//==================================================================================

	// IV. Удаление файла из текущего каталога.:

	char fname[80];
	cout << "Введите название файла для удаления ";
	cin >> fname;// например cppstudio.txt - удалит этот файл из текущего каталога
	if (remove(fname))
	{
		cout << "Ошибка удаления файла ";
		//return 1; // выход 
	}
	//else return 0;
	cout << "\n";
	//==================================================================================

	// V. Переименование файла в текущем каталоге.:

	char fname2[80];
	char fname3[80];
	cout << "Введите название файла для переименования ";
	cin >> fname2; // первоначальное имя
	cout << "Введите новое название файла для переименования ";
	cin >> fname3; // имя после переименования

	if (rename(fname2, fname3))
	{
		cout << "Ошибка переименования файла ";
		//return 1; // выход 
	}
	//else return 0;
	cout << "\n";

	//==================================================================================

	// VI. Перемещение файла из текущего каталога в указанный пользователем каталог:

	char oldWay[100];
	char newWay[100];
	//cout << "Введите путь к файлу для перемещения ";
	//cin >> oldWay;
	//cout << "Введите новый путь к файлу для перемещения ";
	//cin >> newWay;

	cout << "Функция перемещения файла\n";

	BOOL bFile;
	bFile = MoveFile(
		LPCTSTR oldWay,
		LPCTSTR newWay);

	if (bFile == FALSE)
	{
		cout << "Ошибка перемещения файла" << GetLastError() << "\n";
	}
	cout << "Перемещение выполнено успешно" << "\n";

	//==================================================================================

	// VII. Вывод значений файла на экран консоли:

	cout << "Вывод содержимого файла на экран консоли" << "\n";
	char fName[80];
	cout << "Введите название файла для вывода его содержимого на экран консоли: "<<"\n";
	cin >> fName; // первоначальное имя

	string line;
	ifstream myfile(fName);
	if (myfile.is_open())
	{
		while (!myfile.eof())
		{
			getline(myfile, line);
			cout << line << endl;
		}
		myfile.close();
	}

	else cout << "Ошибка открытия файла";

	return 0;
}

